

/**
	Auto generated by xproto.exe
@author
	Dany
*/

#pragma once
#include <list>
#include <vector>
#include <map>
#include <set>
#include <string>


#ifdef WIN32
#include <atlbase.h>
#import <msxml6.dll> 
#include <sstream>

#define XSTRING_STREAM		std::wostringstream 
#define XP_XMLDOCPTR		MSXML2::IXMLDOMDocument2Ptr 
#define XP_XMLNODE_PTR		MSXML2::IXMLDOMNodePtr 
#define XP_XML_NODELIST_PTR	MSXML2::IXMLDOMNodeListPtr 
#define XML_TCHAR			wchar_t

#else
#ifndef _T
#define _T(x) x
#endif

#ifndef NULL

#if defined(__amd64__) || defined(__x86_64__)
#define NULL 0l
#else
#define NULL 0
#endif

#endif

#ifndef BOOL
#define BOOL int
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif


#include <strstream>
#include <libxml/xmlmemory.h> 
#include <libxml/parser.h> 

#define XSTRING_STREAM	std::strstream 
#define XP_XMLDOCPTR	xmlDocPtr
#define XP_XMLNODE_PTR	xmlNodePtr
#define XP_XML_NODELIST_PTR	xmlNodePtr
#define XML_TCHAR		char

#endif

#include "beanip.h"

typedef char 						CHAR;
typedef unsigned char 				UCHAR;
typedef short 						SHORT;
typedef unsigned short 				USHORT;
typedef int 						INT;
typedef unsigned int 				UINT;

#ifdef WIN32

typedef __int64 					LONGLONG;
typedef unsigned __int64			ULONGLONG;

#else 
#if defined(__amd64__) || defined(__x86_64__)
typedef long						LONGLONG;
typedef unsigned long				ULONGLONG;
#else
typedef long long 					LONGLONG;
typedef unsigned long long			ULONGLONG;
#endif

#endif
typedef float						FLOAT;
typedef double						DOUBLE;
typedef std::string				    STRINGA;

#ifdef WIN32
typedef std::wstring				STRINGW;
#endif


//enum _EXPROTO_TYPE{
//	echar=0,euchar,eshort,eushort,eint,euint,elonglong,eulonglong,ufloat,udouble,ustringa,ustringw,uobject,uarray
//};

struct XPROTO_PACKET_HEADER
{
	UINT len;
	UINT cmd;
};


typedef std::vector<UCHAR>					TXPROTO_RAWDATA_BLOCK;
typedef std::list<TXPROTO_RAWDATA_BLOCK *>  TXPROTO_PACKET_QUEUE;



#define PACKET_HEADER_SIZE 8
#define  XPROTO_FAILED					-1
#define  XPROTO_REMAIN_LENGTH_ERROR		-2
#define  XPROTO_XCMD_OUT_OF_RANGE		-3
#define  XPROTO_PACKET_LENGTH_OVERFLOW	-4
#define  XPROTO_PACKET_NOT_COMPLETED	-5
#define  XPROTO_PACKET_LESS_THAN_HDRLEN	-6
#define  XPROTO_DISPATCH_EXCEPTION		-7
#define  XPROTO_OUT_OF_MEMORY			-8
#define  XPROTO_GET_SEND_BUFF_FAILED	-9
#define  XPROTO_FROM_BUFF_FAILED		-10
#define  XPROTO_TO_BUFF_FAILED			-11
#define  XPROTO_XML_NODE_NOT_FOUND		-12
#define  XPROTO_TOO_LESS_HEADER_LINE	-13
#define  XPROTO_MAGIC_NOT_MATCH			-14
#define  XPROTO_TOO_LESS_HEADER_VALUE	-15
#define  XPROTO_PROTOCOL_STATE_WRONG	-16
#define  XPROTO_PARSE_HEADER_FAILED		-17
#define  XPROTO_MAX_HEADER_LEN			-18
#define  XPROTO_UNKOWN_CONTENT_TYPE		-19
#define  XPROTO_UNSUPPORT_TRANS_TYPE	-20



#define  XPROTO_DISP_ACTION_STOP				0
#define  XPROTO_DISP_ACTION_CONTINUE			1
#define  XPROTO_DISP_ACTION_QUEUE				2


inline INT _xmemcpy(  void *dest,   const void *src,   INT count )
{
		memcpy(dest,src,count);
		return count;
}



inline INT XSIZE_OF(CHAR x){return 1;}
inline INT XSIZE_OF(UCHAR x){return 1;}
inline INT XSIZE_OF(SHORT x){return 2;}
inline INT XSIZE_OF(USHORT x){return 2;}
inline INT XSIZE_OF(INT x){return 4;}
inline INT XSIZE_OF(UINT x){return 4;}
inline INT XSIZE_OF(LONGLONG x){return 8;}
inline INT XSIZE_OF(ULONGLONG x){return 8;}
inline INT XSIZE_OF(FLOAT x){return 4;}
inline INT XSIZE_OF(DOUBLE x){return 8;}
inline INT XSIZE_OF(STRINGA const & x)
{
	INT len = (INT)(x.length()+1);
	return len+ 4;
}
#ifdef WIN32
inline INT XSIZE_OF(STRINGW const & x){
	INT len = (INT)(x.length()*2+2); 
	return len+ 4;
}
#endif

template<typename _Ty> 
INT XSIZE_OF(_bean_ptr_t<_Ty> const & x){
	return x->Size();
}

template<typename _Ty>
INT XSIZE_OF(std::vector<_Ty> &x){
	INT nSize= 0;
	
	UINT len = (UINT)x.size();
	if(len>0x2ffffff)
	{
		return 0;
	}
	
	nSize += 4;
	
	for(UINT i=0;i<x.size();i++)
	{
		_Ty const &temp = x[i];
		nSize += XSIZE_OF(temp );
	}
	return nSize;
}

template<typename _Ty>
INT XSIZE_OF_DA_SIMPLE(std::vector<_Ty> &x){
	INT nSize= 0;
	
	UINT len = (UINT)x.size();
	if(len>0x2ffffff)
	{
		return 0;
	}
	
	nSize += 4;
	nSize += sizeof(_Ty)*len;
	
	return nSize;
}


//---------------------------------------------------------------------------------------------------------------------

inline INT XFROM_BUFFER(CHAR &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(UCHAR &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(SHORT &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}


inline INT XFROM_BUFFER(USHORT &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}


inline INT XFROM_BUFFER(INT &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(UINT &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(LONGLONG &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(ULONGLONG &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(FLOAT &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

inline INT XFROM_BUFFER(DOUBLE &dest,   const char *src,   INT maxlen)
{
		if(maxlen>=XSIZE_OF(dest))
				return _xmemcpy(&dest,src,XSIZE_OF(dest));
		else
				return 0;
}

template<typename _T>
INT XFROM_BUFFER(_bean_ptr_t<_T> & dest,   const char *src,   INT maxlen)
{
		return dest->FromBuffer((const char*)src,maxlen);
}

#define XFROM_BUFFER_SAFE(_a,_b,_c,_o)  if(true){INT tmpx = XFROM_BUFFER(_a,_b,_c); if(tmpx==0)return 0; else _o+=tmpx;}


template<typename _T>
INT XFROM_BUFFER(std::vector< _bean_ptr_t<_T> > &x,  const char *src,   INT maxlen){
	
	INT offset = 0;
	INT len=0;

	XFROM_BUFFER_SAFE(len,src,maxlen,offset);
	
	//clear old  data
	//
	x.clear();
	for(int i=0;i<len;i++)
	{
		_bean_ptr_t<_T> t;
		t.CreateInstance();
		XFROM_BUFFER_SAFE(t,src+offset,maxlen-offset,offset);
		x.push_back(t);
	}

	return offset;
}




template<typename _Ty>
INT XFROM_BUFFER_DA_SIMPLE(std::vector<_Ty> &x,  const char *src,   INT maxlen){
	
	INT offset = 0;
	INT len=0;

	XFROM_BUFFER_SAFE(len,src,maxlen,offset);

	x.clear();
	if(len==0)
	{
		return offset;
	}
	x.resize(len);
	if((INT)(sizeof(_Ty)*len)>(maxlen-offset))
		return 0;
	
	offset+=_xmemcpy(&(x[0]),src+offset,sizeof(_Ty)*len);

	return offset;
}

#define XFROM_BUFFER_DA_SIMPLE_SAFE(_a,_b,_c,_o)  if(true){INT tmpx = XFROM_BUFFER_DA_SIMPLE(_a,_b,_c); if(tmpx==0)return 0; else _o+=tmpx;}



inline INT XFROM_BUFFER(STRINGA &x,  const char *src,   INT maxlen){
	INT offset = 0;
	INT strSize = 0;
	XFROM_BUFFER_SAFE(strSize,src,maxlen,offset);
	if(offset ==0||strSize<1 || strSize>(maxlen-offset) || *(src+strSize+offset-1)!=0) 
	{
		return 0;
	}
	
	x  = (const char*)(src+offset);
	offset+=strSize;

	return offset;
}

#ifdef WIN32
inline INT XFROM_BUFFER(STRINGW &x,  const char *src,   INT maxlen){
	INT offset = 0;
	INT strSize = 0;
	XFROM_BUFFER_SAFE(strSize,src,maxlen,offset);
	
	if(offset ==0||strSize<2 || strSize>(maxlen-offset) || *((XML_TCHAR*)(src+strSize+offset-2))!=0) 
	{
		return 0;
	}

	x  = (const XML_TCHAR*)(src+offset);
	offset+=strSize;

	return offset;
}
#endif

inline 
INT XFROM_BUFFER(std::vector<STRINGA> &x,  const char *src,   INT maxlen){
	
	INT offset = 0;
	INT len=0;

	XFROM_BUFFER_SAFE(len,src,maxlen,offset);
	
	//clear old  data
	//
	x.clear();
	x.resize(len);

	for(int i=0;i<len;i++)
	{
		STRINGA  & pt =x[i];		
		XFROM_BUFFER_SAFE(pt,src+offset,maxlen-offset,offset);
	}

	return offset;
}

#ifdef WIN32
inline 
INT XFROM_BUFFER(std::vector<STRINGW> &x,  const char *src,   INT maxlen){
	
	INT offset = 0;
	INT len=0;

	XFROM_BUFFER_SAFE(len,src,maxlen,offset);
	
	//clear old  data
	//
	x.clear();
	x.resize(len);

	for(int i=0;i<len;i++)
	{
		STRINGW  & pt =x[i];		
		XFROM_BUFFER_SAFE(pt,src+offset,maxlen-offset,offset);
	}

	return offset;
}
#endif

//---------------------------------------------------------------------------------------------------------------------

inline INT XTO_BUFFER(CHAR src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}

inline INT XTO_BUFFER(UCHAR src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(SHORT src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(USHORT src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(INT src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(UINT src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(LONGLONG src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(ULONGLONG src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}

inline INT XTO_BUFFER(FLOAT src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}
inline INT XTO_BUFFER(DOUBLE src, char *dest,INT  maxlen)
{
	if(maxlen>=XSIZE_OF(src))
		return _xmemcpy(dest,&src,XSIZE_OF(src));
	else
		return 0;
}


inline INT XTO_BUFFER(STRINGA &x,  char *dst,   INT maxlen){
	INT offset = 0;
	INT szSize = (UINT)x.length()+1;
    offset += XTO_BUFFER(szSize,dst,maxlen);
	if(offset==0|| szSize > (maxlen-offset))
	{
		return 0;
	}
	offset += _xmemcpy(dst+offset,x.c_str(), szSize);
	return offset;
}

#ifdef WIN32

inline INT XTO_BUFFER(STRINGW &x,  char *dst,   INT maxlen){
	INT offset = 0;
	INT szSize = (INT)x.length()*2+2;
    offset += XTO_BUFFER(szSize,dst,maxlen);
	if(offset==0|| szSize > (maxlen-offset))
	{
		return 0;
	}
	offset += _xmemcpy(dst+offset,x.c_str(), szSize);
	
	return offset;
}
#endif

template<typename _T>
INT XTO_BUFFER(_bean_ptr_t<_T> const &src,   char *dest,   INT maxlen)
{
	return src->ToBuffer(dest,maxlen);
}

#define XTO_BUFFER_SAFE(_a,_b,_c,_o)  if(true){INT tmpx = XTO_BUFFER(_a,_b,_c); if(tmpx==0)return 0; else _o+=tmpx;}



template<typename _T>
INT XTO_BUFFER(std::vector< _bean_ptr_t<_T> > &x,  char *dest,   INT maxlen){
	UINT len = (UINT)x.size();
	INT offset = 0;
	XTO_BUFFER_SAFE(len,dest,maxlen,offset);
	for(UINT i=0;i<len;i++)
	{
		_bean_ptr_t<_T> & temp = x[i];
		XTO_BUFFER_SAFE( temp,dest+offset,maxlen-offset,offset);
	}
	return offset;
}

inline 
INT XTO_BUFFER(std::vector<STRINGA> &x,  char *dest,   INT maxlen){
	UINT len = (UINT)x.size();
	INT offset = 0;
	XTO_BUFFER_SAFE(len,dest,maxlen,offset);
	for(UINT i=0;i<len;i++)
	{
		STRINGA  & temp = x[i];
		XTO_BUFFER_SAFE( temp,dest+offset,maxlen-offset,offset);
	}
	return offset;
}
#ifdef WIN32
inline 
INT XTO_BUFFER(std::vector<STRINGW> &x,  char *dest,   INT maxlen){
	UINT len = (UINT)x.size();
	INT offset = 0;
	XTO_BUFFER_SAFE(len,dest,maxlen,offset);

	for(UINT i=0;i<len;i++)
	{
		STRINGW & temp = x[i];
		XTO_BUFFER_SAFE(temp,dest+offset,maxlen-offset,offset);
	}
	return offset;
}
#endif



template<typename _Ty>
INT XTO_BUFFER_DA_SIMPLE(std::vector<_Ty> &x,  char *dest,   INT maxlen){
	UINT len = (UINT)x.size();
	INT offset = 0;
	XTO_BUFFER_SAFE(len,dest,maxlen,offset);
	if((INT)(sizeof(_Ty)*len) > (maxlen-offset))
	{
		return 0;
	}

	if(len>0)
	{
		offset +=_xmemcpy(dest+offset,&(x[0]),sizeof(_Ty)*len);
	}
	
	return offset;
}

#define XTO_BUFFER_DA_SIMPLE_SAFE(_a,_b,_c,_o)  if(true){INT tmpx = XTO_BUFFER_DA_SIMPLE(_a,_b,_c); if(tmpx==0)return 0; else _o+=tmpx;}

//------------------------------------------------------------------------------------------

static XP_XMLDOCPTR XML_LoadFromFile( const XML_TCHAR * sFilename )
{
	
	
#ifdef WIN32
	XP_XMLDOCPTR spDocument;
	spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument60));
	spDocument->async = VARIANT_FALSE;
	spDocument->validateOnParse = VARIANT_FALSE;
	spDocument->preserveWhiteSpace = VARIANT_TRUE;
	spDocument->setProperty(L"NewParser", true);

	if ( !spDocument->load( sFilename ) ){
		spDocument.Release();
		return NULL;
	}

	return spDocument;
#else //#ifdef WIN32
	XP_XMLDOCPTR doc=NULL; 
	doc = xmlParseFile(sFilename); 
	if (doc == NULL ) { 
		return NULL; 
	} 
	return doc;
#endif //#ifdef WIN32

}

static XP_XMLDOCPTR XML_LoadFromString( const XML_TCHAR * sXml )
{
#ifdef WIN32
	XP_XMLDOCPTR spDocument;

	spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument60));
	spDocument->async = VARIANT_FALSE;
	spDocument->validateOnParse = VARIANT_FALSE;
	spDocument->preserveWhiteSpace = VARIANT_TRUE;
	spDocument->setProperty(L"NewParser", true);

	if (!spDocument->loadXML(_bstr_t(sXml))){
		spDocument.Release();
		return NULL;
	}
	return spDocument;
#else //#ifdef WIN32
	XP_XMLDOCPTR doc=NULL; 
	doc = xmlParseMemory(sXml,strlen(sXml)); 
	if (doc == NULL ) { 
		return NULL; 
	} 
	return doc;
#endif //#ifdef WIN32

}


inline XP_XMLNODE_PTR FIND_XML_NODE(XP_XMLNODE_PTR  pNode, XML_TCHAR* lpszNodeName,INT nIndex )
{

	if( pNode == NULL ){
		return NULL;
	}

#ifdef WIN32	
	if( lpszNodeName == NULL ){
		if( (XML_TCHAR*)pNode->text == NULL ){
			return NULL;
		}
		return pNode;
	}else{
		XP_XML_NODELIST_PTR pNodes;

		pNodes = pNode->selectNodes(lpszNodeName);
		
		if(pNodes!=NULL && pNodes->length > nIndex)
		{
			return pNodes->item[nIndex];
		}
	}

#else
	if( lpszNodeName == NULL ){
		if( (XML_TCHAR*)pNode->content == NULL ){
			return NULL;
		}
		return pNode;
	}else{
		XP_XML_NODELIST_PTR cur = pNode->xmlChildrenNode; 

		int curIndex = 0;
		while (cur != NULL)
		{
			if(!xmlStrcmp(cur->name, (const xmlChar *)lpszNodeName))
			{
				if(nIndex==curIndex)
					return cur;

				curIndex ++;
			}
			cur = cur->next;
		}
	}
#endif
	return NULL;
}





inline INT XFROM_XML(CHAR &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (CHAR)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (CHAR)atoi((const char*)pn->content);
#endif

	return 0;
}

inline INT XFROM_XML(UCHAR &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (UCHAR)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (UCHAR)atoi((const char*)pn->content);
#endif
	return 0;

}

inline INT XFROM_XML(SHORT &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (SHORT)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (SHORT)atoi((const char*)pn->content);
#endif
	return 0;
}

inline INT XFROM_XML(USHORT &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (USHORT)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (USHORT)atoi((const char*)pn->content);
#endif

	return 0;
}

inline INT XFROM_XML(INT &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;

#ifdef WIN32
	dest = (INT)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (INT)atoi((const char*)pn->content);
#endif

	return 0;
}


inline INT XFROM_XML(UINT &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (UINT)_wtoi((XML_TCHAR*)pn->text);
#else
	dest = (UINT)atoi((const char*)pn->content);
#endif
	return 0;
}

inline INT XFROM_XML(LONGLONG &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (LONGLONG)_wtoi64((XML_TCHAR*)pn->text);
#else
#if defined(__amd64__) || defined(__x86_64__)
	dest = (LONGLONG)atol((const char*)pn->content);
#else
	dest = (LONGLONG)atoll((const char*)pn->content);
#endif
#endif
	return 0;
}

inline INT XFROM_XML(ULONGLONG &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (ULONGLONG)_wtoi64((XML_TCHAR*)pn->text);
#else
#if defined(__amd64__) || defined(__x86_64__)
	dest = (ULONGLONG)atol((const char*)pn->content);
#else
	dest = (ULONGLONG)atoll((const char*)pn->content);
#endif
#endif
	return 0;
}

inline INT XFROM_XML(FLOAT &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0.0f;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (FLOAT)_wtof((XML_TCHAR*)pn->text);
#else 
	dest = atof((const char*)pn->content);
#endif

	return 0;
}

inline INT XFROM_XML(DOUBLE &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	dest = 0.0;
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = (DOUBLE)_wtof((XML_TCHAR*)pn->text);
#else
	dest = atof((const char*)pn->content);
#endif
	return 0;
}

inline INT XFROM_XML(STRINGA& dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
#ifdef WIN32
	USES_CONVERSION;
#endif
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
#ifdef WIN32
	dest = W2A( (XML_TCHAR*)pn->text);
#else
	dest = (const char*)pn->content;
#endif
	return 0;
}

#ifdef WIN32
inline INT XFROM_XML(STRINGW &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{	
	dest.clear();
	XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
	if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
	dest = (XML_TCHAR*)pn->text;
	return 0;
}
#endif


template<typename _T>
inline INT XFROM_XML(_bean_ptr_t<_T> &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{	
	if( dest == NULL || pNode == NULL ){
		return -1;
	}

	if( lpszNodeName == NULL ){
		
		return dest->FromXml( pNode );

	}else{
			XP_XMLNODE_PTR pn = FIND_XML_NODE(pNode,lpszNodeName,nIndex);
			if(pn==NULL) return XPROTO_XML_NODE_NOT_FOUND;
			return dest->FromXml(pn);
	}

	return 0;
}

template <typename _T>
INT XFROM_XML(std::vector< _bean_ptr_t<_T> >  &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	if( pNode == NULL )
		return -1;

	dest.clear();

	
	XP_XMLNODE_PTR pNodeIt;
#ifdef WIN32
	XP_XML_NODELIST_PTR pNodes;
	pNodes = pNode->selectNodes(lpszNodeName);
	for( int i = 0; pNodes != NULL && i < pNodes->length; i++ ){
		pNodeIt = pNodes->item[i];	 
#else
	pNodeIt = pNode->xmlChildrenNode; 
	while(pNodeIt){
#endif
				

		_bean_ptr_t<_T>  t;
		t.CreateInstance();
		if( t ){
			if( XFROM_XML( t, pNodeIt,NULL,0 ) == 0  ){
				dest.push_back( t );
			}
		}
#ifndef WIN32
		pNodeIt = pNodeIt->next;
#endif

	}

	return 0;

}

template <typename _T>
INT XFROM_XML(std::vector<_T>  &dest,XP_XMLNODE_PTR  pNode,XML_TCHAR* lpszNodeName,INT nIndex)
{
	if( pNode == NULL )
		return -1;

	XP_XMLNODE_PTR pNodeIt;
#ifdef WIN32
	XP_XML_NODELIST_PTR pNodes;
	pNodes = pNode->selectNodes(lpszNodeName);
	for( int i = 0; pNodes !=NULL && i < pNodes->length; i++ ){
		pNodeIt = pNodes->item[i];	 		
#else
	pNodeIt = pNode->xmlChildrenNode; 
	while(pNodeIt){
#endif
		_T t;
		if( XFROM_XML( t,pNodeIt,NULL,0 ) == 0  ){
			dest.push_back( t );
		}
#ifndef WIN32
		pNodeIt = pNodeIt->next;
#endif
	}

	return 0;

}

//---------------------------------------------------------------------------------------------------------------------

#ifdef WIN32
#define XTO_XML_P(s,o,n){o<< L"<" << n<< L">" << s << L"</"<< n<< L">";}
#else
#define XTO_XML_P(s,o,n){o<< "<" << n<< ">" << s << "</"<< n<< ">";}
#endif

inline INT XTO_XML( CHAR src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( UCHAR src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );	
	return 0;
}

inline INT XTO_XML( SHORT src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( USHORT src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( INT src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( UINT src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( LONGLONG src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( ULONGLONG src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( FLOAT src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	out<< std::fixed;
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( DOUBLE src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{	
	out<< std::fixed;
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

inline INT XTO_XML( const CHAR* src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{		
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}

#ifdef WIN32
inline INT XTO_XML( const XML_TCHAR* src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{		
	XTO_XML_P( src,out,lpszNodeName );
	return 0;
}
#endif

inline INT XTO_XML( STRINGA src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{		
	XTO_XML_P( src.c_str(),out,lpszNodeName );
	return 0;
}

#ifdef WIN32
inline INT XTO_XML( STRINGW src,XSTRING_STREAM & out,XML_TCHAR* lpszNodeName)
{		
	XTO_XML_P( src.c_str(),out,lpszNodeName );
	return 0;
}
#endif


template<typename _T>
inline INT XTO_XML( _bean_ptr_t<_T> &src,XSTRING_STREAM &out, XML_TCHAR* lpszNodeName )
{	
	if( src == NULL )
		return -1;
#ifdef WIN32
	out<< L"<" << lpszNodeName << L">";
#else
	out<< "<" << lpszNodeName << ">";
#endif
	src->ToXml( out );	

#ifdef WIN32
	out<< L"</" << lpszNodeName << L">";
#else
	out<< "</" << lpszNodeName << ">";
#endif

	return 0;
}

template <typename _T>
INT XTO_XML(std::vector<_T> &src,XSTRING_STREAM &out,XML_TCHAR* lpszNodeName )
{
	size_t nSize = src.size();

	for( size_t i = 0; i < nSize; i++ ){
		XTO_XML( src[i],out,lpszNodeName );
	}

	return 0;
}


//------private-------------------------------------------------------



/*::PRIVATE_DEFINES::*/

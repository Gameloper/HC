/**
	Auto generated by xproto.exe
@author
	Dany
*/
#pragma once

#ifndef WIN32
inline 
long  InterlockedIncrement (volatile long *value)
{
#if !defined(CC_TARGET_OS_IPHONE) && !defined(CC_TARGET_OS_MAC) && !defined(ANDROID)
#if defined(__i386__) || defined(__x86_64__) || defined(__amd64__)
  long tmp = 1;
  unsigned long addr = reinterpret_cast<unsigned long> (value);
  asm( "lock ; xadd %0, (%1)" : "+r"(tmp) : "r"(addr) );
  return tmp + 1;
#endif
#else
  return (*value) ++ ;
  
#endif
}
inline 
long
InterlockedDecrement (volatile long *value)
{
	#if !defined(CC_TARGET_OS_IPHONE) && !defined(CC_TARGET_OS_MAC) && !defined(ANDROID)
#if defined(__i386__) || defined(__x86_64__) || defined(__amd64__)
  long tmp = -1;
  unsigned long addr = reinterpret_cast<unsigned long> (value);
  asm( "lock ; xadd %0, (%1)" : "+r"(tmp) : "r"(addr) );
  return tmp - 1;
#endif
#else
	 return (*value) --;;
#endif
}
#endif

/**
	implement it yourself to print or raise execeptions
*/
void _bean_issue_error(int);

/**
	base class for auto pointer .
*/
class _auto_pointer_class_base
{

public:
	 // object id, CCScriptSupport need public m_uID
    unsigned int        m_uID;
    // Lua reference id
    int                 m_nLuaID;
	virtual long AddRef();
	virtual long Release();
protected:
	_auto_pointer_class_base()
	{
		m_refcount = 1;
	}
	virtual ~_auto_pointer_class_base()
	{

	}
private:
	volatile long m_refcount;
};

#ifdef WIN32
#ifndef XINT_PTR
#define XINT_PTR int
#endif
#else
#ifndef XINT_PTR
#define XINT_PTR long
#endif
#endif
/**
	Smart pointer to avoid unneccessary memory copy, 
	and pass forward the packet convieniently and effetively.
*/
template<class __Txi> class _bean_ptr_t {
public:

	// Default constructor.
    //
    _bean_ptr_t() throw()
        : m_pInterface(NULL)
    {

    }


    // Constructs a smart-pointer from other smart pointer.
    //
    _bean_ptr_t(const _bean_ptr_t<__Txi>& p) 
    {
		if(p!=NULL)
			p->AddRef();
		m_pInterface = p.GetInterfacePtr();
    }


    // This constructor is provided to allow NULL assignment. It will issue
    // an error if any value other than null is assigned to the object.
    //
	_bean_ptr_t(XINT_PTR null) 
        : m_pInterface(NULL)
    {
        if (null != 0) {
            _bean_issue_error(0x80004003L);
        }
    }

    // Saves the interface.
    //
    _bean_ptr_t(__Txi* pInterface)  throw()
    { 
		if(pInterface!=NULL)
			pInterface->AddRef(); 
		m_pInterface = pInterface;
    }

    // Copies the pointer. If fAddRef is TRUE, the interface will
    // be AddRef()ed.
    //
    _bean_ptr_t(__Txi* pInterface, bool fAddRef) throw()
    {
		if(!pInterface && fAddRef)
			pInterface->AddRef();

        m_pInterface = pInterface;
    }

    // Queries for interface.
    //
    _bean_ptr_t<__Txi>& operator=(const _bean_ptr_t<__Txi>& p) 
    {
		return operator=(p.GetInterfacePtr());
    }

    // Saves the interface.
    //
    _bean_ptr_t<__Txi>& operator=(__Txi* pInterface) throw()
    {
        if (m_pInterface != pInterface) {
            __Txi* pOldInterface = m_pInterface;
			
			if(pInterface!=NULL)			
				pInterface->AddRef();

            m_pInterface = pInterface;

            if (pOldInterface != NULL) {
                pOldInterface->Release();
            }
        }
        return *this;
    }

    // This operator is provided to permit the assignment of NULL to the class.
    // It will issue an error if any value other than NULL is assigned to it.
    //
    _bean_ptr_t& operator=(XINT_PTR null) 
    {
        if (null != 0) {
            _bean_issue_error(0x80004003L);
        }
		
        return operator=(reinterpret_cast<__Txi*>(NULL));
    }

   
    // If we still have an interface then Release() it. The interface
    // may be NULL if Detach() has previously been called, or if it was
    // never set.
    //
    ~_bean_ptr_t() 
    { 
        _Release(); 
    }

    // Saves/sets the interface without AddRef()ing. This call
    // will release any previously acquired interface.
    //
    void Attach(__Txi* pInterface) 
    {
        _Release();
        m_pInterface = pInterface;
    }

    // Saves/sets the interface only AddRef()ing if fAddRef is TRUE.
    // This call will release any previously acquired interface.
    //
    void Attach(__Txi* pInterface, bool fAddRef) throw()
    {
        _Release();
        m_pInterface = pInterface;

        if (fAddRef) {
            if (pInterface == NULL) {
                _bean_issue_error(0x80004003L);
            } 
            else {
                pInterface->AddRef();
            }
        }
    }

    // Simply NULL the interface pointer so that it isn't Released()'ed.
    //
    __Txi* Detach() throw()
    {
        __Txi* const old = m_pInterface;
        m_pInterface = NULL;
        return old;
    }

    // Return the interface. This value may be NULL.
    //
    operator __Txi*() const throw()
    { 
        return m_pInterface; 
    }

    // Queries for the unknown and return it
    // Provides minimal level error checking before use.
    //
    operator __Txi&() const 
    { 
        if (m_pInterface == NULL) {
            _bean_issue_error(0x80004003L);
        }

        return *m_pInterface; 
    }

    // Allows an instance of this class to act as though it were the
    // actual interface. Also provides minimal error checking.
    //
    __Txi& operator*() const 
    { 
        if (m_pInterface == NULL) {
            _bean_issue_error(0x80004003L);
        }

        return *m_pInterface; 
    }

	/*__Txi* operator&() const
    {
        if (m_pInterface == NULL) {
            _bean_issue_error(0x80004003L);
        }
        return m_pInterface;
    }*/

    // Allows this class to be used as the interface itself.
    // Also provides simple error checking.
    //
    __Txi* operator->() const 
    { 
        if (m_pInterface == NULL) {
           _bean_issue_error(0x80004003L);
        }
        return m_pInterface; 
    }

    // This operator is provided so that simple boolean expressions will
    // work.  For example: "if (p) ...".
    // Returns TRUE if the pointer is not NULL.
    //
    operator bool() const 
    { 
        return m_pInterface != NULL; 
    }

    // Compare two smart pointers
    //
    bool operator==(const _bean_ptr_t<__Txi>& p) 
    {
        return (m_pInterface == p.m_pInterface);
    }

    // Compare with other interface
    //
    bool operator==(const __Txi* p) 
    {
        return (m_pInterface == p);
    }

    // For comparison to NULL
    //
    bool operator==(XINT_PTR null) 
    {
        if (null != 0) {
            //_bean_issue_error(0x80004003L);
        }
        return m_pInterface == NULL;
    }

    // Compare two smart pointers
    //
    bool operator!=(const _bean_ptr_t<__Txi>& p) 
    {
        return !(operator==(p));
    }


	// Compare two pointers
    //
	bool operator!=(const __Txi* p) 
    {
        return !(operator==(p));
    }

    // For comparison to NULL
    //
    bool operator!=(XINT_PTR null) 
    {
        return !(operator==(null));
    }

    // Provides error-checking Release()ing of this interface.
    //
    void Release() 
    {
        if (m_pInterface == NULL) {
            _bean_issue_error(0x80004003L);
        }
        else {
            m_pInterface->Release();
            m_pInterface = NULL;
        }
    }

    // Provides error-checking AddRef()ing of this interface.
    //
    void AddRef() 
    { 
        if (m_pInterface == NULL) {
            _bean_issue_error(0x80004003L);
        }
        else {
            m_pInterface->AddRef();
        }
    }

    // Another way to get the interface pointer without casting.
    //
    __Txi* GetInterfacePtr() const 
    { 
        return m_pInterface; 
    }

    // Another way to get the interface pointer without casting.
    // Use for [in, out] parameter passing
    __Txi*& GetInterfacePtr() 
    { 
        return m_pInterface; 
    }

    // Loads an interface for the provided CLSID.
    // Returns an HRESULT.  Any previous interface is unconditionally released.
    //
    int CreateInstance() 
    {
		int hr=0;
		m_pInterface = __Txi::CreateInstance();
		if(m_pInterface==NULL) hr = 0x80004003L;
        return hr;
    }

private:
    // The __Txi.
    //
    __Txi* m_pInterface;

    // Releases only if the interface is not null.
    // The interface is not set to NULL.
    //
    void _Release() throw()
    {
        if (m_pInterface != NULL) {
            m_pInterface->Release();
        }
    }

    // AddRefs only if the interface is not NULL
    //
    void _AddRef() throw()
    {
        if (m_pInterface != NULL) {
            m_pInterface->AddRef();
        }
    }

};

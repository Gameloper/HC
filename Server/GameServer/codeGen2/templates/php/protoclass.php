<?php
/**
	Auto generated by xproto.exe
@author
	Dany
*/

require_once ($GLOBALS['GAME_ROOT']."config.php");
require_once ($GLOBALS['GAME_ROOT']."log/Logger.php");
require_once ($GLOBALS['GAME_ROOT']."log/LogProfile.php");
require_once("XByteArray.php");
require_once("/*::TYPES_HEADER_FILE::*/.php");
		
class /*::PROTOCLASSNAME::*/ 
{
		
		public	$_m_bOutputNetworkDetails	= true;
		
    public  $useAMF = false;
    
		private static $_s_OpHandlers=  array(
			"_NullActionHandler","_NullActionHandler",
/*::OPHANDLER_ENTRY::*/
		);
    
    
		private static $_s_SendOpcodeNames = array(
			0=>"_NullAction",
/*::SEND_OPCODE_NAME_ENTRY::*/
		);	

    private $_s_msg_index_map= array(
/*::MSG_INDEX_MAP_ENTRIES::*/
    );

    private $callback = array();
    
    public function registerCallBack($target,$class,$function)
    {
    	if(empty($target) || empty($class) || empty($function)){
    		return false;
    	}
    	$this->callback[$target] = array($class,"{$function}");
    	
    	return true;
    }
   
    
    private function get_index_of_msg($msg)
    {
       if(!array_key_exists($msg,$this->_s_msg_index_map))
       {
          return 0;
       }
       return $this->_s_msg_index_map[$msg] ;
    }
        
		private function OutputNetworkDetails($bSend, $cmd, $data)
		{
			
		}
	
		
		private static function _NullActionHandler($data/*:XByteArray*/)
		{
			echo __FILE__.__LINE__."FATAL ERROR, SHOULD NEVER BE HERE.... _NullActionHandler";
			return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;;
		}
		
		
		
		public function HandleReceivedData($data)/*:int*/
		{
				$br = new XByteArray();
				$br->set_data($data);
				if($br->getBytesAvailable()<8)
				{
					  return XPROTO_ERROR_CODE::XPROTO_PACKET_LESS_THAN_HDRLEN;
				}
        
				while($br->getBytesAvailable()>=8)
				{
					$savePos = $br->position;
					$len = $br->readInt32();
					$cmd = $br->readInt32();
	        
					if($len>$br->length)
					{
					    return XPROTO_ERROR_CODE::XPROTO_PACKET_LENGTH_OVERFLOW;
					}
          
					if($cmd<=0 || $cmd> /*::ENUM_EVENT_MSG_MAX::*/ || $cmd < /*::ENUM_EVENT_MSG_MIN::*/)
					{
					    return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					$br->position = $savePos;
          
					$msg_idx = /*::GET_INDEX_OF_MSG::*/($cmd);
					if($msg_idx<=0)
					{
						return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;  
					}
          
					/**
					 * make sure the action is valid
					 */
					$action  = /*::PROTOCLASSNAME::*/::$_s_OpHandlers[2*$msg_idx];	
					if (!$this->CheckValidAction($action, $cmd))
					{
						return XPROTO_ERROR_CODE::XPROTO_CONNECTION_STATE_CHECK_FAILED;						
					}				
						
					$func = /*::PROTOCLASSNAME::*/::$_s_OpHandlers[1+2*$msg_idx];			
					$tmp = $br->readBinary($len);	
					$packet = new XByteArray();
					$packet->set_data($tmp);
					$ret = $this->$func($packet);		
					if($ret<0)
					{
					    return $ret;
					}
				}
				
				if($br->getBytesAvailable()!=0)
				{
					echo __FILE__." line:".__LINE__." FATAL ERROR, PROTOFAILED dump:".BytesToString($data,strlen($data),' ');
					return XPROTO_ERROR_CODE::XPROTO_REMAIN_LENGTH_ERROR;
				}
				
				return XPROTO_ERROR_CODE::XPROTO_SUCCEED;
		}
		
		public function DispatchReceivedPacket()/*:int*/
		{
				return 0;
					
		} 
		
		function WriteDataToSocket($data/*:XByteArray*/)/*:int*/
		{
			  
		}
		
		public function CheckValidAction($action/*:string*/, $msgId/*INT*/)/*:bool*/
		{
			return true;
		}
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
/*::ORIGINALHANDLER_IMPLEMENTS::*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*::SEND_METHODS_IMPLEMENTS::*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*::LISTENER_INTERFACE_METHODS::*/
}

?>

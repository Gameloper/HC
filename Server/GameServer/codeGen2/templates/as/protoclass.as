/**
	Auto generated by xproto.exe
@author
	Dany
	
	
*/


package /*::PACKAGE_NAME::*/
{
	
	import flash.utils.ByteArray;
	import flash.utils.Endian;
	import flash.events.EventDispatcher;
		
	//
	//@see  /*::LISTENER_INTERFACE_NAME::*/ shows you how to add your event listener.
	//
	public class /*::PROTOCLASSNAME::*/ extends EventDispatcher
	{
		private var _m_pendingPacket:ByteArray = null;
		private var _m_PacketQueue:Array=new Array();
		public	var _m_bOutputNetworkDetails:Boolean = true;
		public	var	_m_bPending:Boolean = false;
		public  var useAMF:Boolean =false;
		private var _s_OpHandlers:Array= new Array();		
		private static var _s_SendOpcodeNames:Array = new  Array();	
		
		private function OutputNetworkDetails(bSend:Boolean , cmd:int, data:ByteArray):void
		{
		
			var szOutput:String;
			if(bSend)
			{
				szOutput = "SEND "+data.length + " "+/*::SEND_OPCODE_ENUM_NAME::*/.getName(cmd)+ " ";
			}
			else
			{
				szOutput = "RECV "+data.length + " "+ /*::RECV_OPCODE_ENUM_NAME::*/.getName(cmd)+ " ";
			}
			
			szOutput +=XProtoMarshaling.ByteArrayToString(data);
			GameMessage.debugTrace(szOutput);
			
		}
	
		public function isRecvNotComplete():Boolean
		{
				return _m_bPending;
		}
		public function /*::PROTOCLASSNAME::*/()
		{
			_s_OpHandlers[0]=_NullActionHandler;
/*::OPHANDLER_ENTRY::*/

		}
		
		
		private static function _NullActionHandler(data:ByteArray):int		
		{
			GameMessage.debugTrace("FATAL ERROR, SHOULD NEVER BE HERE.... _NullActionHandler");
			return 0;
		}
		
		
		public function HandleReceivedData(data:ByteArray):int
		{
			var savePos:uint =0;
			
			var bContinue:XInteger = new XInteger();
			var len:uint = data.bytesAvailable;
			var res:int =0;
			var xlen:int ;
			var xcmd:int ;
			var opHandler:Function ;
			data.endian = Endian.LITTLE_ENDIAN;

			
			
			while(data.bytesAvailable>0)
			{
				if(!_m_bPending)
				{
					//new packet
					//
					if(_m_pendingPacket==null)
					{
						_m_pendingPacket= new ByteArray();
						_m_pendingPacket.endian = Endian.LITTLE_ENDIAN;
					}
					
					_m_pendingPacket.length = 0;
					_m_pendingPacket.position = 0;
					
					
					if(data.bytesAvailable<XProtoMarshaling.PACKET_HEADER_SIZE)
					{
						//header  not completed
						//
						//memcpy(pPendingPacket,pCurrentBuf,byteAvailable);
						data.readBytes(_m_pendingPacket,0, data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
				
					savePos = data.position;
					xlen = data.readInt();
					xcmd = data.readInt();
					data.position = savePos;
		
					//
					//overflow?
					//
					if(xlen<0 || xlen >2000000)
					{
						return XProtoMarshaling.XPROTO_PACKET_LENGTH_OVERFLOW;
					}
		
					if(xcmd<=0 || xcmd > _EMSG_ServerEvent.SMSG_MAX || xcmd < _EMSG_ServerEvent.SMSG_OnServerErrorMessage)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
		
					
					if(_s_OpHandlers[xcmd]==null)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					
					if(data.bytesAvailable < xlen)
					{
						//PACKET NOT COMPLETED?
						//
						//memcpy(pPendingPacket, pCurrentBuf,byteAvailable);
						data.readBytes(_m_pendingPacket,0,data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
		
					data.readBytes(_m_pendingPacket,0,xlen);
					
					//here should be a complete packet.
					//
					_m_PacketQueue.push(_m_pendingPacket);
					_m_pendingPacket = null;
					
					
				}//if pending?
				else
				{
					//packet pending 
					//
					if(_m_pendingPacket.bytesAvailable < XProtoMarshaling.PACKET_HEADER_SIZE)
					{
						var hdrLeft:int = (XProtoMarshaling.PACKET_HEADER_SIZE - _m_pendingPacket.bytesAvailable);
						if(data.bytesAvailable < hdrLeft)
						{
							data.readBytes(_m_pendingPacket,_m_pendingPacket.length,data.bytesAvailable);
							_m_bPending =true;
							return len;
						}
		
						//head completed.
						//
						data.readBytes(_m_pendingPacket,_m_pendingPacket.length, hdrLeft);
					}
		
					savePos = _m_pendingPacket.position;
					xlen	= _m_pendingPacket.readInt();
					xcmd	= _m_pendingPacket.readInt();
					_m_pendingPacket.position = savePos;
		
					//
					//overflow?
					//
					if(xlen<0 || xlen > 2000000)
					{
						return XProtoMarshaling.XPROTO_PACKET_LENGTH_OVERFLOW;
					}
		
					if(xcmd<=0 || xcmd > _EMSG_ServerEvent.SMSG_MAX || xcmd < _EMSG_ServerEvent.SMSG_OnServerErrorMessage)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					if( _s_OpHandlers[xcmd]==null)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
		
					
					var remainLen:int = xlen - _m_pendingPacket.bytesAvailable;
					if(data.bytesAvailable < remainLen)
					{
						//not completed
						//copy and return
						//
						data.readBytes(_m_pendingPacket,_m_pendingPacket.length, data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
		
				
					
					data.readBytes(_m_pendingPacket,_m_pendingPacket.length,remainLen);
		
		
					_m_bPending = false;//pakcet completed
		
					//here should be a complete packet.
					//
					//here should be a complete packet.
					//
					_m_PacketQueue.push(_m_pendingPacket);
					_m_pendingPacket = null;
					
				}
			}//while
			return len;

		}
		
		public function DispatchReceivedPacket():int
		{
			while(_m_PacketQueue.length!=0)
			{
				var pPacket:ByteArray = _m_PacketQueue.shift();
				pPacket.position=0;
				
				pPacket.readInt();
				var xcmd:int = pPacket.readInt();
				pPacket.position = 0;		
				
		
				var opHandler:Function = _s_OpHandlers[xcmd];
		
				//dispath by table;
				//
				var res:int = opHandler(pPacket);
				
				if(res<0)
				{
					return res;
				}
			}
		
			return 0;
					
		} 
		
		
		public function HookReceivedPacket(_m_pendingPacket:ByteArray, bContinue:XInteger):int
		{
			return 1;
		}
		
		public function HandleReceiveDataAndDispatch(data:ByteArray):int
		{
			if(_m_pendingPacket==null)
			{
				_m_pendingPacket= new ByteArray();
				_m_pendingPacket.endian = Endian.LITTLE_ENDIAN;
			}
			
			var savePos:uint =0;
			
			var bContinue:XInteger = new XInteger();
			var len:uint = data.bytesAvailable;
			var res:int =0;
			var xlen:int ;
			var xcmd:int ;
			var opHandler:Function ;
			data.endian = Endian.LITTLE_ENDIAN;

			
			
			while(data.bytesAvailable>0)
			{
				if(!_m_bPending)
				{
					//new packet
					//
					_m_pendingPacket.length = 0;
					_m_pendingPacket.position = 0;
					
					
					if(data.bytesAvailable<XProtoMarshaling.PACKET_HEADER_SIZE)
					{
						//header  not completed
						//
						//memcpy(pPendingPacket,pCurrentBuf,byteAvailable);
						data.readBytes(_m_pendingPacket,0, data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
				
					savePos = data.position;
					xlen = data.readInt();
					xcmd = data.readInt();
					data.position = savePos;
		
					//
					//overflow?
					//
					if(xlen<0 || xlen >2000000)
					{
						return XProtoMarshaling.XPROTO_PACKET_LENGTH_OVERFLOW;
					}
		
					if(xcmd<=0 || xcmd > _EMSG_ServerEvent.SMSG_MAX || xcmd < _EMSG_ServerEvent.SMSG_OnServerErrorMessage)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
		
					
					if(_s_OpHandlers[xcmd]==null)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					
					if(data.bytesAvailable < xlen)
					{
						//PACKET NOT COMPLETED?
						//
						//memcpy(pPendingPacket, pCurrentBuf,byteAvailable);
						data.readBytes(_m_pendingPacket,0,data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
		
					data.readBytes(_m_pendingPacket,0,xlen);
					
					//here should be a complete packet.
					//
					opHandler= _s_OpHandlers[xcmd];
				
					
					//dispactch it 
					//
					
					bContinue._value = 1;
					res = HookReceivedPacket(_m_pendingPacket, bContinue);
					if(bContinue && res >=0)
					{
						res = opHandler(_m_pendingPacket);
					}
		
					if(res<0)
					{
						return res;
					}
					
				}//if pending?
				else
				{
					//packet pending 
					//
					if(_m_pendingPacket.bytesAvailable < XProtoMarshaling.PACKET_HEADER_SIZE)
					{
						var hdrLeft:int = (XProtoMarshaling.PACKET_HEADER_SIZE - _m_pendingPacket.bytesAvailable);
						if(data.bytesAvailable < hdrLeft)
						{
							data.readBytes(_m_pendingPacket,_m_pendingPacket.length,data.bytesAvailable);
							_m_bPending =true;
							return len;
						}
		
						//head completed.
						//
						data.readBytes(_m_pendingPacket,_m_pendingPacket.length, hdrLeft);
					}
		
					savePos = _m_pendingPacket.position;
					xlen	= _m_pendingPacket.readInt();
					xcmd	= _m_pendingPacket.readInt();
					_m_pendingPacket.position = savePos;
		
					//
					//overflow?
					//
					if(xlen<0 || xlen > 2000000)
					{
						return XProtoMarshaling.XPROTO_PACKET_LENGTH_OVERFLOW;
					}
		
					if(xcmd<=0 || xcmd > _EMSG_ServerEvent.SMSG_MAX || xcmd < _EMSG_ServerEvent.SMSG_OnServerErrorMessage)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					if( _s_OpHandlers[xcmd]==null)
					{
						return XProtoMarshaling.XPROTO_XCMD_OUT_OF_RANGE;
					}
		
					
					var remainLen:int = xlen - _m_pendingPacket.bytesAvailable;
					if(data.bytesAvailable < remainLen)
					{
						//not completed
						//copy and return
						//
						data.readBytes(_m_pendingPacket,_m_pendingPacket.length, data.bytesAvailable);
						_m_bPending = true;
						return len;
					}
		
				
					
					data.readBytes(_m_pendingPacket,_m_pendingPacket.length,remainLen);
		
		
					_m_bPending = false;//pakcet completed
		
					
		
					//here should be a complete packet.
					//
					opHandler= _s_OpHandlers[xcmd];
					
					//dispactch it 
					//
					
					bContinue._value = 1;
					res = HookReceivedPacket(_m_pendingPacket,bContinue);
					if(bContinue && res >=0)
					{
						res =opHandler(_m_pendingPacket);
					}
					
		
					if(res<0)
					{
						return res;
					}
				}
			}//while
			return len;
		}

		public function WriteDataToSocket(arr:ByteArray):int
		{
			return 0;
		}
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
/*::ORIGINALHANDLER_IMPLEMENTS::*/



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*::SEND_METHODS_IMPLEMENTS::*/
		
	}
}
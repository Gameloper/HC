<?php
/**
	Auto generated by xproto.exe
@author
	Dany
*/

require_once ($GLOBALS['GAME_ROOT']."config.php");
require_once ($GLOBALS['GAME_ROOT']."Log/Logger.php");
require_once ($GLOBALS['GAME_ROOT']."Log/LogProfile.php");
require_once("XByteArray.php");
require_once("game_idl.php");
		
class GameProtocolServer 
{
		
		public	$_m_bOutputNetworkDetails	= true;
		
    public  $useAMF = false;
    
		private static $_s_OpHandlers=  array(
			"_NullActionHandler","_NullActionHandler",

			"CMSG_DoLogin","_OnDoLogin",
			"CMSG_SendInternalNotifyByProxy","_OnInternalNotifyByProxy",
			"CMSG_OnKickout","_OnKickout",
			"CMSG_SendPing","_OnPing",
			"CMSG_SendProtoBuff","_OnProtoBuff",

		);
    
    
		private static $_s_SendOpcodeNames = array(
			0=>"_NullAction",

			0x00000001=>"SMSG_OnServerErrorMessage",
			0x00000002=>"SMSG_OnSendZipData",
			0x0000002E=>"SMSG_OnPong",
			0x0000002F=>"SMSG_OnProtoReponse",

		);	

    private $_s_msg_index_map= array(

		0x00000001=>1,
		0x0000000C=>2,
		0x00000019=>3,
		0x00000022=>4,
		0x00000023=>5,
    );

    private $callback = array();
    
    public function registerCallBack($target,$class,$function)
    {
    	if(empty($target) || empty($class) || empty($function)){
    		return false;
    	}
    	$this->callback[$target] = array($class,"{$function}");
    	
    	return true;
    }
   
    
    private function get_index_of_msg($msg)
    {
       if(!array_key_exists($msg,$this->_s_msg_index_map))
       {
          return 0;
       }
       return $this->_s_msg_index_map[$msg] ;
    }
        
		private function OutputNetworkDetails($bSend, $cmd, $data)
		{
			
		}
	
		
		private static function _NullActionHandler($data/*:XByteArray*/)
		{
			echo __FILE__.__LINE__."FATAL ERROR, SHOULD NEVER BE HERE.... _NullActionHandler";
			return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;;
		}
		
		
		
		public function HandleReceivedData($data)/*:int*/
		{
				$br = new XByteArray();
				$br->set_data($data);
				if($br->getBytesAvailable()<8)
				{
					  return XPROTO_ERROR_CODE::XPROTO_PACKET_LESS_THAN_HDRLEN;
				}
        
				while($br->getBytesAvailable()>=8)
				{
					$savePos = $br->position;
					$len = $br->readInt32();
					$cmd = $br->readInt32();
	        
					if($len>$br->length)
					{
					    return XPROTO_ERROR_CODE::XPROTO_PACKET_LENGTH_OVERFLOW;
					}
          
					if($cmd<=0 || $cmd> _EMSG_ServerInterface::CMSG_MAX || $cmd < _EMSG_ServerInterface::CMSG_DoLogin)
					{
					    return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					$br->position = $savePos;
          
					$msg_idx = $this->get_index_of_msg($cmd);
					if($msg_idx<=0)
					{
						return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;  
					}
          
					/**
					 * make sure the action is valid
					 */
					$action  = GameProtocolServer::$_s_OpHandlers[2*$msg_idx];	
					if (!$this->CheckValidAction($action, $cmd))
					{
						return XPROTO_ERROR_CODE::XPROTO_CONNECTION_STATE_CHECK_FAILED;						
					}				
						
					$func = GameProtocolServer::$_s_OpHandlers[1+2*$msg_idx];			
					$tmp = $br->readBinary($len);	
					$packet = new XByteArray();
					$packet->set_data($tmp);
					$ret = $this->$func($packet);		
					if($ret<0)
					{
					    return $ret;
					}
				}
				
				if($br->getBytesAvailable()!=0)
				{
					echo __FILE__." line:".__LINE__." FATAL ERROR, PROTOFAILED dump:".BytesToString($data,strlen($data),' ');
					return XPROTO_ERROR_CODE::XPROTO_REMAIN_LENGTH_ERROR;
				}
				
				return XPROTO_ERROR_CODE::XPROTO_SUCCEED;
		}
		
		public function DispatchReceivedPacket()/*:int*/
		{
				return 0;
					
		} 
		
		function WriteDataToSocket($data/*:XByteArray*/)/*:int*/
		{
			  
		}
		
		public function CheckValidAction($action/*:string*/, $msgId/*INT*/)/*:bool*/
		{
			return true;
		}
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		


		private function _OnDoLogin($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_DoLogin.php");
			$pPacket  =  new XPACKET_DoLogin();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug("OnDoLogin");
					}
					$ret = $this->OnDoLogin($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnDoLogin".$pPacket->ToDebugString());
				}

				$ret = $this->OnDoLogin($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnDoLogin " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnInternalNotifyByProxy($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendInternalNotifyByProxy.php");
			$pPacket  =  new XPACKET_SendInternalNotifyByProxy();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug("OnInternalNotifyByProxy");
					}
					$ret = $this->OnInternalNotifyByProxy($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnInternalNotifyByProxy".$pPacket->ToDebugString());
				}

				$ret = $this->OnInternalNotifyByProxy($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnInternalNotifyByProxy " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnKickout($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnKickout.php");
			$pPacket  =  new XPACKET_OnKickout();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug("OnKickout");
					}
					$ret = $this->OnKickout($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnKickout".$pPacket->ToDebugString());
				}

				$ret = $this->OnKickout($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnKickout " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnPing($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendPing.php");
			$pPacket  =  new XPACKET_SendPing();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug("OnPing");
					}
					$ret = $this->OnPing($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnPing".$pPacket->ToDebugString());
				}

				$ret = $this->OnPing($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnPing " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnProtoBuff($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendProtoBuff.php");
			$pPacket  =  new XPACKET_SendProtoBuff();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug("OnProtoBuff");
					}
					$ret = $this->OnProtoBuff($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnProtoBuff".$pPacket->ToDebugString());
				}

				$ret = $this->OnProtoBuff($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnProtoBuff " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		public function SendServerErrorMessage($error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendServerErrorMessage"])){
					$cb = $this->callback["SendServerErrorMessage"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnServerErrorMessage.php");
			$__xvpacketlen/*:int*/ = XPACKET_OnServerErrorMessage::_Size($error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_OnServerErrorMessage::_ClassFromParameters($error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ );
			   Logger::getLogger()->debug("SendServerErrorMessage");
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_OnServerErrorMessage::toAMFObject($__xvbuf,$error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ );
			}
			else
			{
				$__xvres = XPACKET_OnServerErrorMessage::_ToBuffer($__xvbuf,$error_code/*:INT*/ ,$lpszMsg/*:string utf-8*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_OnServerErrorMessage::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendSendZipData($zipData/*:UCHAR[] */ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendSendZipData"])){
					$cb = $this->callback["SendSendZipData"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($zipData/*:UCHAR[] */ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnSendZipData.php");
			$__xvpacketlen/*:int*/ = XPACKET_OnSendZipData::_Size($zipData/*:UCHAR[] */ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_OnSendZipData::_ClassFromParameters($zipData/*:UCHAR[] */ );
			   Logger::getLogger()->debug("SendSendZipData");
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_OnSendZipData::toAMFObject($__xvbuf,$zipData/*:UCHAR[] */ );
			}
			else
			{
				$__xvres = XPACKET_OnSendZipData::_ToBuffer($__xvbuf,$zipData/*:UCHAR[] */ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_OnSendZipData::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendPong($time/*:string utf-8*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendPong"])){
					$cb = $this->callback["SendPong"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($time/*:string utf-8*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnPong.php");
			$__xvpacketlen/*:int*/ = XPACKET_OnPong::_Size($time/*:string utf-8*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_OnPong::_ClassFromParameters($time/*:string utf-8*/ );
			   Logger::getLogger()->debug("SendPong");
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_OnPong::toAMFObject($__xvbuf,$time/*:string utf-8*/ );
			}
			else
			{
				$__xvres = XPACKET_OnPong::_ToBuffer($__xvbuf,$time/*:string utf-8*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_OnPong::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendProtoReponse($error_code/*:INT*/ ,$data/*:UCHAR[] */ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendProtoReponse"])){
					$cb = $this->callback["SendProtoReponse"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($error_code/*:INT*/ ,$data/*:UCHAR[] */ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnProtoReponse.php");
			$__xvpacketlen/*:int*/ = XPACKET_OnProtoReponse::_Size($error_code/*:INT*/ ,$data/*:UCHAR[] */ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_OnProtoReponse::_ClassFromParameters($error_code/*:INT*/ ,$data/*:UCHAR[] */ );
			   Logger::getLogger()->debug("SendProtoReponse");
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_OnProtoReponse::toAMFObject($__xvbuf,$error_code/*:INT*/ ,$data/*:UCHAR[] */ );
			}
			else
			{
				$__xvres = XPACKET_OnProtoReponse::_ToBuffer($__xvbuf,$error_code/*:INT*/ ,$data/*:UCHAR[] */ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_OnProtoReponse::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		public function OnDoLogin($pPacket/*XPACKET_DoLogin*/)/*:int*/
		{
		    return 0;
		}
		public function OnInternalNotifyByProxy($pPacket/*XPACKET_SendInternalNotifyByProxy*/)/*:int*/
		{
		    return 0;
		}
		public function OnKickout($pPacket/*XPACKET_OnKickout*/)/*:int*/
		{
		    return 0;
		}
		public function OnPing($pPacket/*XPACKET_SendPing*/)/*:int*/
		{
		    return 0;
		}
		public function OnProtoBuff($pPacket/*XPACKET_SendProtoBuff*/)/*:int*/
		{
		    return 0;
		}

}

?>

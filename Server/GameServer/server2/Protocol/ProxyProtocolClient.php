<?php
/**
	Auto generated by xproto.exe
@author
	Dany
*/

require_once ($GLOBALS['GAME_ROOT']."config.php");
require_once ($GLOBALS['GAME_ROOT']."Log/Logger.php");
require_once ($GLOBALS['GAME_ROOT']."Log/LogProfile.php");
require_once("XByteArray.php");
require_once("proxy_idl.php");
		
class ProxyProtocolClient 
{
		
		public	$_m_bOutputNetworkDetails	= true;
		
    public  $useAMF = false;
    
		private static $_s_OpHandlers=  array(
			"_NullActionHandler","_NullActionHandler",

			"SMSG_OnServerErrorMessage","_OnServerErrorMessage",
			"SMSG_OnPong","_OnPong",

		);
    
    
		private static $_s_SendOpcodeNames = array(
			0=>"_NullAction",

			0x0000000C=>"CMSG_SendInternalNotifyByProxy",
			0x00000022=>"CMSG_SendPing",

		);	

    private $_s_msg_index_map= array(

		0x00000001=>1,
		0x00000003=>2,
		0x00000004=>3,
		0x00000001=>1,
		0x0000002E=>2,
    );

    private $callback = array();
    
    public function registerCallBack($target,$class,$function)
    {
    	if(empty($target) || empty($class) || empty($function)){
    		return false;
    	}
    	$this->callback[$target] = array($class,"{$function}");
    	
    	return true;
    }
   
    
    private function get_index_of_msg($msg)
    {
       if(!array_key_exists($msg,$this->_s_msg_index_map))
       {
          return 0;
       }
       return $this->_s_msg_index_map[$msg] ;
    }
        
		private function OutputNetworkDetails($bSend, $cmd, $data)
		{
			
		}
	
		
		private static function _NullActionHandler($data/*:XByteArray*/)
		{
			echo __FILE__.__LINE__."FATAL ERROR, SHOULD NEVER BE HERE.... _NullActionHandler";
			return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;;
		}
		
		
		
		public function HandleReceivedData($data)/*:int*/
		{
				$br = new XByteArray();
				$br->set_data($data);
				if($br->getBytesAvailable()<8)
				{
					  return XPROTO_ERROR_CODE::XPROTO_PACKET_LESS_THAN_HDRLEN;
				}
        
				while($br->getBytesAvailable()>=8)
				{
					$savePos = $br->position;
					$len = $br->readInt32();
					$cmd = $br->readInt32();
	        
					if($len>$br->length)
					{
					    return XPROTO_ERROR_CODE::XPROTO_PACKET_LENGTH_OVERFLOW;
					}
          
					if($cmd<=0 || $cmd> _EMSG_ProxyServerEvent::SMSG_MAX || $cmd < _EMSG_ProxyServerEvent::SMSG_OnServerErrorMessage)
					{
					    return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					$br->position = $savePos;
          
					$msg_idx = $this->get_index_of_msg($cmd);
					if($msg_idx<=0)
					{
						return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;  
					}
          
					/**
					 * make sure the action is valid
					 */
					$action  = ProxyProtocolClient::$_s_OpHandlers[2*$msg_idx];	
					if (!$this->CheckValidAction($action, $cmd))
					{
						return XPROTO_ERROR_CODE::XPROTO_CONNECTION_STATE_CHECK_FAILED;						
					}				
						
					$func = ProxyProtocolClient::$_s_OpHandlers[1+2*$msg_idx];			
					$tmp = $br->readBinary($len);	
					$packet = new XByteArray();
					$packet->set_data($tmp);
					$ret = $this->$func($packet);		
					if($ret<0)
					{
					    return $ret;
					}
				}
				
				if($br->getBytesAvailable()!=0)
				{
					echo __FILE__." line:".__LINE__." FATAL ERROR, PROTOFAILED dump:".BytesToString($data,strlen($data),' ');
					return XPROTO_ERROR_CODE::XPROTO_REMAIN_LENGTH_ERROR;
				}
				
				return XPROTO_ERROR_CODE::XPROTO_SUCCEED;
		}
		
		public function DispatchReceivedPacket()/*:int*/
		{
				return 0;
					
		} 
		
		function WriteDataToSocket($data/*:XByteArray*/)/*:int*/
		{
			  
		}
		
		public function CheckValidAction($action/*:string*/, $msgId/*INT*/)/*:bool*/
		{
			return true;
		}
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		


		private function _OnServerErrorMessage($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnServerErrorMessage.php");
			$pPacket  =  new XPACKET_OnServerErrorMessage();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnServerErrorMessage".$pPacket->ToDebugString());
					}
					$ret = $this->OnServerErrorMessage($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnServerErrorMessage".$pPacket->ToDebugString());
				}

				$ret = $this->OnServerErrorMessage($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnServerErrorMessage " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnPong($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnPong.php");
			$pPacket  =  new XPACKET_OnPong();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnPong".$pPacket->ToDebugString());
					}
					$ret = $this->OnPong($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnPong".$pPacket->ToDebugString());
				}

				$ret = $this->OnPong($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnPong " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		public function SendInternalNotifyByProxy($action/*:INT*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendInternalNotifyByProxy"])){
					$cb = $this->callback["SendInternalNotifyByProxy"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($action/*:INT*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendInternalNotifyByProxy.php");
			$__xvpacketlen/*:int*/ = XPACKET_SendInternalNotifyByProxy::_Size($action/*:INT*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_SendInternalNotifyByProxy::_ClassFromParameters($action/*:INT*/ );
			   Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." SendInternalNotifyByProxy".$c->ToDebugString());
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_SendInternalNotifyByProxy::toAMFObject($__xvbuf,$action/*:INT*/ );
			}
			else
			{
				$__xvres = XPACKET_SendInternalNotifyByProxy::_ToBuffer($__xvbuf,$action/*:INT*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_SendInternalNotifyByProxy::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendPing($time/*:string utf-8*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendPing"])){
					$cb = $this->callback["SendPing"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($time/*:string utf-8*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendPing.php");
			$__xvpacketlen/*:int*/ = XPACKET_SendPing::_Size($time/*:string utf-8*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_SendPing::_ClassFromParameters($time/*:string utf-8*/ );
			   Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." SendPing".$c->ToDebugString());
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_SendPing::toAMFObject($__xvbuf,$time/*:string utf-8*/ );
			}
			else
			{
				$__xvres = XPACKET_SendPing::_ToBuffer($__xvbuf,$time/*:string utf-8*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_SendPing::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		public function OnServerErrorMessage($pPacket/*XPACKET_OnServerErrorMessage*/)/*:int*/
		{
		    return 0;
		}
		public function OnPong($pPacket/*XPACKET_OnPong*/)/*:int*/
		{
		    return 0;
		}

}

?>

<?php
/**
	Auto generated by xproto.exe
@author
	Dany
*/

require_once ($GLOBALS['GAME_ROOT']."config.php");
require_once ($GLOBALS['GAME_ROOT']."Log/Logger.php");
require_once ($GLOBALS['GAME_ROOT']."Log/LogProfile.php");
require_once("XByteArray.php");
require_once("proxy_idl.php");
		
class LocalDeamonProtocolClient 
{
		
		public	$_m_bOutputNetworkDetails	= true;
		
    public  $useAMF = false;
    
		private static $_s_OpHandlers=  array(
			"_NullActionHandler","_NullActionHandler",

			"SMSG_OnMutiplecastLocalError","_OnMutiplecastLocalError",
			"SMSG_OnScheduleTimerResult","_OnScheduleTimerResult",
			"SMSG_OnCancelTimerResult","_OnCancelTimerResult",

		);
    
    
		private static $_s_SendOpcodeNames = array(
			0=>"_NullAction",

			0x00000001=>"CMSG_SendMutiplecastLocal",
			0x00000003=>"CMSG_ScheduleTimer",
			0x00000004=>"CMSG_CancelTimer",

		);	

    private $_s_msg_index_map= array(

		0x00000001=>1,
		0x00000003=>2,
		0x00000004=>3,
    );

    private $callback = array();
    
    public function registerCallBack($target,$class,$function)
    {
    	if(empty($target) || empty($class) || empty($function)){
    		return false;
    	}
    	$this->callback[$target] = array($class,"{$function}");
    	
    	return true;
    }
   
    
    private function get_index_of_msg($msg)
    {
       if(!array_key_exists($msg,$this->_s_msg_index_map))
       {
          return 0;
       }
       return $this->_s_msg_index_map[$msg] ;
    }
        
		private function OutputNetworkDetails($bSend, $cmd, $data)
		{
			
		}
	
		
		private static function _NullActionHandler($data/*:XByteArray*/)
		{
			echo __FILE__.__LINE__."FATAL ERROR, SHOULD NEVER BE HERE.... _NullActionHandler";
			return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;;
		}
		
		
		
		public function HandleReceivedData($data)/*:int*/
		{
				$br = new XByteArray();
				$br->set_data($data);
				if($br->getBytesAvailable()<8)
				{
					  return XPROTO_ERROR_CODE::XPROTO_PACKET_LESS_THAN_HDRLEN;
				}
        
				while($br->getBytesAvailable()>=8)
				{
					$savePos = $br->position;
					$len = $br->readInt32();
					$cmd = $br->readInt32();
	        
					if($len>$br->length)
					{
					    return XPROTO_ERROR_CODE::XPROTO_PACKET_LENGTH_OVERFLOW;
					}
          
					if($cmd<=0 || $cmd> _EMSG_LocalEvent::SMSG_MAX || $cmd < _EMSG_LocalEvent::SMSG_OnMutiplecastLocalError)
					{
					    return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;
					}
					
					$br->position = $savePos;
          
					$msg_idx = $this->get_index_of_msg($cmd);
					if($msg_idx<=0)
					{
						return XPROTO_ERROR_CODE::XPROTO_XCMD_OUT_OF_RANGE;  
					}
          
					/**
					 * make sure the action is valid
					 */
					$action  = LocalDeamonProtocolClient::$_s_OpHandlers[2*$msg_idx];	
					if (!$this->CheckValidAction($action, $cmd))
					{
						return XPROTO_ERROR_CODE::XPROTO_CONNECTION_STATE_CHECK_FAILED;						
					}				
						
					$func = LocalDeamonProtocolClient::$_s_OpHandlers[1+2*$msg_idx];			
					$tmp = $br->readBinary($len);	
					$packet = new XByteArray();
					$packet->set_data($tmp);
					$ret = $this->$func($packet);		
					if($ret<0)
					{
					    return $ret;
					}
				}
				
				if($br->getBytesAvailable()!=0)
				{
					echo __FILE__." line:".__LINE__." FATAL ERROR, PROTOFAILED dump:".BytesToString($data,strlen($data),' ');
					return XPROTO_ERROR_CODE::XPROTO_REMAIN_LENGTH_ERROR;
				}
				
				return XPROTO_ERROR_CODE::XPROTO_SUCCEED;
		}
		
		public function DispatchReceivedPacket()/*:int*/
		{
				return 0;
					
		} 
		
		function WriteDataToSocket($data/*:XByteArray*/)/*:int*/
		{
			  
		}
		
		public function CheckValidAction($action/*:string*/, $msgId/*INT*/)/*:bool*/
		{
			return true;
		}
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		


		private function _OnMutiplecastLocalError($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnMutiplecastLocalError.php");
			$pPacket  =  new XPACKET_OnMutiplecastLocalError();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnMutiplecastLocalError".$pPacket->ToDebugString());
					}
					$ret = $this->OnMutiplecastLocalError($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnMutiplecastLocalError".$pPacket->ToDebugString());
				}

				$ret = $this->OnMutiplecastLocalError($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnMutiplecastLocalError " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnScheduleTimerResult($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnScheduleTimerResult.php");
			$pPacket  =  new XPACKET_OnScheduleTimerResult();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnScheduleTimerResult".$pPacket->ToDebugString());
					}
					$ret = $this->OnScheduleTimerResult($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnScheduleTimerResult".$pPacket->ToDebugString());
				}

				$ret = $this->OnScheduleTimerResult($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnScheduleTimerResult " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}
		private function _OnCancelTimerResult($__src)
		{
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_OnCancelTimerResult.php");
			$pPacket  =  new XPACKET_OnCancelTimerResult();
			
			$ret = -1;
			$start_time = microtime(TRUE);
			
			if(!$this->useAMF)
			{
				$__len		= $__src->getBytesAvailable();
				if($pPacket->FromBuffer($__src)!=$__len)
				{
					
				}
				else
				{
					if (DEBUG)
					{
					    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnCancelTimerResult".$pPacket->ToDebugString());
					}
					$ret = $this->OnCancelTimerResult($pPacket);			
				}
				
				
			}
			else
			{				

				$obj = ReadAMF3Object($__src);
				$pPacket->fromAMFObject($obj);
				
				if (DEBUG)
				{
				    Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." OnCancelTimerResult".$pPacket->ToDebugString());
				}

				$ret = $this->OnCancelTimerResult($pPacket);
			}


			$run_time = microtime(TRUE) - $start_time;
			
			if($run_time >= 0.01){
				LogProfile::getInstance()->log("OnCancelTimerResult " . $run_time . " MYSQL_CONNECT_TIME:" . MySQL::$connect_time . " QUERY_TIME:" . MySQL::$query_time . " WRITE_LOG_TIME:" . Logger::$log_time);
			}
			
			return $ret;
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		public function SendMutiplecastLocal($targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendMutiplecastLocal"])){
					$cb = $this->callback["SendMutiplecastLocal"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_SendMutiplecastLocal.php");
			$__xvpacketlen/*:int*/ = XPACKET_SendMutiplecastLocal::_Size($targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_SendMutiplecastLocal::_ClassFromParameters($targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ );
			   Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." SendMutiplecastLocal".$c->ToDebugString());
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_SendMutiplecastLocal::toAMFObject($__xvbuf,$targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ );
			}
			else
			{
				$__xvres = XPACKET_SendMutiplecastLocal::_ToBuffer($__xvbuf,$targets/*:PROXY_TARGET_LOCAL[] */ ,$bIncluded/*:UCHAR*/ ,$pPacket/*:UCHAR[] */ ,$bWaitDetailResult/*:UCHAR*/ ,$bKickout/*:UCHAR*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_SendMutiplecastLocal::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendScheduleTimer($bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendScheduleTimer"])){
					$cb = $this->callback["SendScheduleTimer"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_ScheduleTimer.php");
			$__xvpacketlen/*:int*/ = XPACKET_ScheduleTimer::_Size($bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_ScheduleTimer::_ClassFromParameters($bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ );
			   Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." SendScheduleTimer".$c->ToDebugString());
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_ScheduleTimer::toAMFObject($__xvbuf,$bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ );
			}
			else
			{
				$__xvres = XPACKET_ScheduleTimer::_ToBuffer($__xvbuf,$bRepeating/*:UCHAR*/ ,$milliSecond/*:INT*/ ,$scriptfileName/*:string utf-8*/ ,$className/*:string utf-8*/ ,$params/*:string utf-8*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_ScheduleTimer::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}


		public function SendCancelTimer($timerId/*:string utf-8*/ )
		{
			if(defined('TESTING') && TESTING){
				if(isset($this->callback["SendCancelTimer"])){
					$cb = $this->callback["SendCancelTimer"];
					$cls_obj = $cb[0];
					$function = $cb[1];	
					$cls_obj->$function($timerId/*:string utf-8*/ );
				}		
				return 0;	
			}
			
			require_once($GLOBALS['GAME_ROOT'] . "Protocol/XPACKET_CancelTimer.php");
			$__xvpacketlen/*:int*/ = XPACKET_CancelTimer::_Size($timerId/*:string utf-8*/ );
			$__xvbuf	= new XByteArray();
			//$__xvbuf->reserve($__xvpacketlen);
			
			
			$__xvres/*:int*/ = 0;
			
			if (DEBUG)
			{
			   $c = XPACKET_CancelTimer::_ClassFromParameters($timerId/*:string utf-8*/ );
			   Logger::getLogger()->debug($_SERVER[_ECUSTOM_HEADER::socket_id]." SendCancelTimer".$c->ToDebugString());
			}
			
			if($this->useAMF)
			{
				$__xvres = XPACKET_CancelTimer::toAMFObject($__xvbuf,$timerId/*:string utf-8*/ );
			}
			else
			{
				$__xvres = XPACKET_CancelTimer::_ToBuffer($__xvbuf,$timerId/*:string utf-8*/ );
				if($__xvres !=$__xvpacketlen)
				{
					return -1;
				}
				if($this->_m_bOutputNetworkDetails)
				{
					$this->OutputNetworkDetails(true,XPACKET_CancelTimer::$_m_xcmd,$__xvbuf);
				}
			
			
			}

			$__xvres = $this->WriteDataToSocket($__xvbuf);
			return $__xvres;
		}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		public function OnMutiplecastLocalError($pPacket/*XPACKET_OnMutiplecastLocalError*/)/*:int*/
		{
		    return 0;
		}
		public function OnScheduleTimerResult($pPacket/*XPACKET_OnScheduleTimerResult*/)/*:int*/
		{
		    return 0;
		}
		public function OnCancelTimerResult($pPacket/*XPACKET_OnCancelTimerResult*/)/*:int*/
		{
		    return 0;
		}

}

?>


/**
	Auto generated by xproto.exe
@author
	Dany
*/

#pragma once

#include "game_idl.h"
#include <vector>
#include <list>
#include <map>

namespace LegendX {



///////////////////////////////////////////////////////////////////////////////////////////////////

class GameProtocolClient :public _auto_pointer_class_base
{
private:

	typedef	INT (GameProtocolClient::* _TOPCODEHANDLER)(const char *__src,INT    __len);

	static _TOPCODEHANDLER _s_OpHandlers[];

	TXPROTO_RAWDATA_BLOCK *_m_pendingPacket;
	INT					   _m_FinishedPacketLen;
	INT					   _m_remainingPacketLen;
	UCHAR				   _m_PacketHeader[8];
	UCHAR				   _m_PacketHeaderSize;
	TXPROTO_PACKET_QUEUE   _m_PacketQueue;
	bool				   _m_bEnableNetworksDebugOutput;
	bool				   _m_bPending;
	
	void OutputNetworkDetails(bool bSend, INT xcmd, const UCHAR *buf, int len);
	static inline long get_index_of_msg(long smsg);
	static std::map<long,long>	_s_msg_index_map;
public:
	static int init_static_map();

private:
	INT DispAction(XPROTO_PACKET_HEADER *phdr);
	INT CheckPacketHeader(XPROTO_PACKET_HEADER *phdr);
	INT NullActionHandler(const char *__src,INT    __len);
	//
	//ORIGINALHANDLER_DEFINES
	//
    INT _OnServerErrorMessage(const char* __src,int __len);
    INT _OnSendZipData(const char* __src,int __len);
    INT _OnPong(const char* __src,int __len);
    INT _OnProtoReponse(const char* __src,int __len);

	
protected:
	//
	//HANDLER_METHODS_DEFINES
	//
	//UtraEdit regular express for generating code for a inherit class.
	//FIND:^(*^)virtual INT ^(*^)(^(*^))=0;^p
	//FOR HEADER REPLACE WITH:^1void	^2IoCp(AsyncStoreQueryResult &dbres,^3,void *lpv);^p^1INT ^2(^3);^p
	//FOR CPP    REPLACE WITH:void YOURCLASSNAME::^2IoCp(AsyncStoreQueryResult &dbres,^3,void *lpv)^p{^p   ^p}^pINT YOURCLASSNAME::^2(^3)^p{^p    return 0;^p}^p
	//
    virtual INT OnServerErrorMessage(XPACKET_OnServerErrorMessagePtr pPacket)=0;
    virtual INT OnSendZipData(XPACKET_OnSendZipDataPtr pPacket)=0;
    virtual INT OnPong(XPACKET_OnPongPtr pPacket)=0;
    virtual INT OnProtoReponse(XPACKET_OnProtoReponsePtr pPacket)=0;

public:
	void ResetInternalData();
        void ClearInternalData();

	inline TXPROTO_PACKET_QUEUE * getqueue()
	{
		return &_m_PacketQueue;
	}

	inline bool queue_empty()
	{
		return _m_PacketQueue.empty();
	}

	inline TXPROTO_RAWDATA_BLOCK *dequeue()
	{
		if(!_m_PacketQueue.empty())
		{
			TXPROTO_RAWDATA_BLOCK * p = _m_PacketQueue.front();
			_m_PacketQueue.pop_front();
			return p;
		}
		return NULL;
	}

	inline void backqueue(TXPROTO_RAWDATA_BLOCK *pp)
	{	
		_m_PacketQueue.push_front(pp);
	}

	inline void enqueue(char *buf, int len)
	{
		TXPROTO_RAWDATA_BLOCK* pp =  new TXPROTO_RAWDATA_BLOCK(len);
		memcpy(&(*pp)[0],buf,len);
		_m_PacketQueue.push_back(pp);
	}

	GameProtocolClient();
	virtual ~GameProtocolClient();
	
	/**
	@return 
	>=0 num Of  bytes processed.
	-1 BAD DATA, SHOULD CLOSE CONNECTION
	
	*/
	virtual INT HandleReceivedData(char *buf, INT len);

	/**
	@return 
	-1 BAD DATA, SHOULD CLOSE CONNECTION
	*/
	virtual INT DispatchReceivedPacket();

	/**
		less memcpy and faster
	*/
	INT HandleReceiveDataAndDispatch(char *buf,INT len);

	/**
		HandleReceiveDataAndDispatch and HandleReceivedData will call it this function firstly 
		after a full packet receieved, you can override it to do some action before packet 
		dispactch to real handler function, such as stop call it real handler function or decrypt.
		@param lpbContinue, set to 1, if you wanto continue,2 if you want to put it in queue
		set 0 if you want to stop dispatching.

		@return 
			0 and positive is good.
			Negative is bad , you should stop handling.
	*/
	virtual INT HookReceivedPacket(char *packet,INT len, INT *lpAction)
	{
		*lpAction = XPROTO_DISP_ACTION_CONTINUE;
		return 0;
	}

	
	bool EnableNetworksDebugOutput(bool bEnable)
	{
		_m_bEnableNetworksDebugOutput = bEnable;
		return _m_bEnableNetworksDebugOutput;
	}
	
protected:
	/**
	@return num of written.
	*/
	/*virtual INT WriteDataToSocket(const char *buf,INT buflen)=0;*/
	/*virtual INT WriteDataToSocket(class ACE_Message_Block *mblk)=0;*/
	virtual INT WriteDataToSocket()=0;
	
	virtual char *GetSendBuffer(INT nNeedSize)=0;
	virtual INT MaxPacketLength()=0;
public:
	//INT SendNullAction(int x,STRINGA &y);
	//
	//SEND_METHODS_DEFINES
	//
    INT SendDoLogin(std::string&  userId,std::string&  server,std::string&  sessionKey,std::string&  version);
    INT SendInternalNotifyByProxy(int  action);
    INT SendKickout(int  error_code);
    INT SendPing(std::string&  time);
    INT SendProtoBuff(std::vector<unsigned char>&  data);

};



/////////////////////////////////////////////////////////////////////////////////////////////////////

}